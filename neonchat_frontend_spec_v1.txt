NeonChat Frontend UI/UX: Technical Specification for LLM Implementation
1. Introduction
This document provides a detailed technical specification for building the frontend user interface (UI) and user experience (UX) of the NeonChat application, which is evolving into an AI-powered journaling and project management system. This specification is intended to guide an LLM coder (e.g., Claude Code) in implementing the frontend.
Core Technologies:
Build Tool: Vite
JavaScript: Vanilla JavaScript (ES6+)
Styling: Tailwind CSS (primary), with custom CSS in frontend/static/css/styles.css and potentially frontend/static/css/journal.css for specific theming.
HTML Structure: Defined in frontend/static/index.html.
Backend Communication: Via HTTP REST APIs and WebSockets to a FastAPI backend.
Guiding Principles for Implementation:
Modularity: JavaScript code should be organized into logical modules/classes where appropriate (e.g., AuthService, JournalUI, ProjectUI, ApiService).
Responsiveness: The UI must be responsive and adapt to various screen sizes (mobile, tablet, desktop).
Accessibility: Implement with accessibility best practices in mind (semantic HTML, ARIA attributes where necessary, keyboard navigation).
Clarity: Code should be well-commented, and HTML should use meaningful IDs and classes.
Error Handling: Implement basic error handling for API calls and display user-friendly messages.
Reference Existing Code: The existing frontend/static/js/app.js and frontend/static/index.html should be used as a base and modified/extended. The existing Tron-themed styling in styles.css should be maintained and extended.
2. Staged Implementation Plan
Stage 1: Core Layout, Navigation, and Authentication Shell
Objective: Establish the main application shell, static sidebar navigation, view switching, and integrate Firebase Google Sign-In.
1.1. HTML Structure (index.html modifications):
* Review neonchat_journal_architecture_v1 Section 1 (Frontend Application).
* Confirm the main layout:
* Static sidebar (<nav class="sidebar">) always visible on the left.
* Main content area (<main class="main-content-revert">) to the right of the sidebar.
* Sidebar Navigation:
* Ensure links for "Chat", "Journal", "Projects", and "Settings" are present.
* Assign data-section attributes to each link (e.g., data-section="chat", data-section="journal").
* Main Content Views:
* Define distinct div containers for each section within <main>:
* <section id="chat-view" class="content-section active">...</section> (reuse existing chat view structure)
* <section id="journal-view" class="content-section" style="display: none;">...</section> (placeholder)
* <section id="projects-view" class="content-section" style="display: none;">...</section> (placeholder)
* <section id="settings-view" class="content-section" style="display: none;">...</section> (placeholder)
* Authentication Elements:
* Add a "Sign In with Google" button, styled appropriately, visible when the user is not authenticated.
* Add a "Sign Out" button and user display area (e.g., for username/avatar), visible when authenticated, likely in the sidebar or a top bar within the main content area.
1.2. JavaScript Logic (auth.js - new file, and app.js modifications):
* auth.js:
* Implement Firebase SDK initialization (using placeholder config initially, to be replaced with actual Firebase config variables later).
* Implement signInWithGoogle() function.
* Implement signOutUser() function.
* Implement onAuthStateChangedListener(callback) to notify app.js of auth state changes.
* Function getCurrentUser() to return user object or null.
* Function getIdToken() to retrieve the current user's ID token.
* app.js:
* Import functions from auth.js.
* Initialize onAuthStateChangedListener.
* On sign-in: Hide "Sign In" button, show "Sign Out" button and user info. Fetch initial data if necessary.
* On sign-out: Show "Sign In" button, hide "Sign Out" button and user info. Clear user-specific data.
* Implement navigation logic:
* Event listeners for sidebar navigation links.
* Function setActiveView(sectionId):
* Hides all .content-section elements.
* Shows the section with id === sectionId.
* Updates the active class on navigation links.
* The "Sign In" button should call auth.signInWithGoogle().
* The "Sign Out" button should call auth.signOutUser().
1.3. Styling (Tailwind CSS & styles.css):
* Ensure the sidebar is fixed and main content area takes remaining space.
* Style authentication buttons and user display area consistent with the Tron theme.
* Active navigation link styling.
1.4. API Interaction:
* No direct backend API calls in this stage, focus on Firebase client-side auth.
Stage 2: Core Chat Interface
Objective: Re-establish and verify the existing chat functionality within the new layout.
2.1. HTML Structure (index.html within #chat-view):
* Reference existing index.html for the chat UI components.
* Ensure these elements are present:
* Chat messages container (<div id="chat-messages">).
* Image preview area (<div id="image-preview">).
* Chat input textarea (<textarea id="chat-input">).
* File input button/label (<label for="file-input">).
* Send button (<button id="send-button">).
* Typing indicator placeholder.
2.2. JavaScript Logic (app.js or a new chat.js module):
* Reference existing app.js for chat logic.
* WebSocket Connection:
* Establish WebSocket connection to the backend (/ws) on successful authentication.
* Handle onopen, onmessage, onclose, onerror events.
* Store client ID received from the server.
* Message Sending (sendMessage function):
* Handles text messages.
* Handles image uploads:
* Reads image file, converts to base64.
* Sends message object with type: 'image', base64 content, and optional caption.
* Sends appropriate JSON structure to WebSocket.
* Message Receiving & Display (displayMessage function):
* Handles incoming text messages, image messages, system messages, and errors.
* Renders Markdown content using marked.parse().
* Displays images.
* Handles streaming text chunks (type: 'text_chunk') and final done: true signals.
* Manages typing indicators.
* Chat History:
* Load chat history from localStorage on initialization.
* Save new messages (user and assistant) to localStorage.
* UI Interactions:
* Auto-resize chat input textarea.
* Image preview functionality.
* Clearing image preview.
* Enter key to send message (Shift+Enter for newline).
2.3. Styling:
* Verify all existing chat UI styles from styles.css are correctly applied.
* Ensure chat canvas scrolls correctly.
2.4. API Interaction (WebSocket):
* Send messages in the format: { type: 'text'/'image', role: 'user', content: '...', caption: '...', model_id: 'claude-3-7-sonnet-20250219', provider: 'Claude' }.
* Receive messages: { role: 'assistant'/'system', content: '...', type: 'text'/'image'/'error'/'text_chunk', done: true/false }.
Stage 3: Journaling UI - New Entry & Metrics
Objective: Implement the "New Entry" and "Daily Metrics" tabs within the Journal view.
3.1. HTML Structure (index.html within #journal-view):
* Tab Navigation:
* Buttons for "New Entry", "Recent Entries", "Daily Metrics", "Analytics".
* Container divs for each tab's content (e.g., <div id="journal-tab-new-entry" class="journal-tab active">).
* "New Entry" Tab Content (#journal-tab-new-entry):
* <form id="journal-entry-form">:
* Title input: <input type="text" id="journal-title" name="title">.
* Content textarea: <textarea id="journal-content" name="content" rows="10"></textarea>.
* Image attachment: <input type="file" id="journal-image-upload" name="image" accept="image/*"> and an image preview area.
* Structured Metrics (examples, expand based on user's detailed list):
* Mood: <label for="journal-mood">Mood (1-10):</label><input type="range" id="journal-mood" name="mood" min="1" max="10" value="5"> <span id="journal-mood-value">5</span>
* Energy Level: Similar range slider.
* Sleep Hours: <input type="number" id="journal-sleep" name="sleep" step="0.5">.
* Water Intake (glasses): <input type="number" id="journal-water" name="water">.
* Exercise (minutes): <input type="number" id="journal-exercise" name="exercise">.
* (Add more for: weather, prayer, work, marriage, friends, etc. as number/slider inputs)
* MCP Tool Toggles Area (<div id="journal-mcp-toggles">):
* Placeholders for toggles (e.g., "AI Tagging", "AI Observations"). These will be dynamically populated.
* Submit button: <button type="submit">Save Journal Entry</button>.
* Area to display AI Therapist response/questions (<div id="journal-ai-chat-area">). This will be an interactive chat pane similar to the main chat, but specific to the journal entry context.
* "Daily Metrics" Tab Content (#journal-tab-metrics):
* <form id="daily-metrics-form">:
* Date picker (default to today): <input type="date" id="metrics-date" name="date">.
* Inputs for all daily trackable metrics (sleep, water, exercise, stress, happiness, etc., similar to the journal form but potentially more comprehensive or separated).
* Submit button: <button type="submit">Save Daily Metrics</button>.
* Area to display calculated well-being score (<div id="wellbeing-score-display">).
3.2. JavaScript Logic (journal.js - new file):
* Module/Class JournalUI:
* Tab Switching Logic: Handle clicks on journal tab buttons to show/hide respective content divs.
* "New Entry" Form (#journal-entry-form):
* Event listener for submit.
* Collect all form data (title, content, metrics, image).
* If image attached: read as base64.
* Call backend API (/api/journal/entry - POST) with the data.
* Handle response: Display success/error message. Clear form. Potentially update "Recent Entries".
* Interactive AI Journaling:
* When user types in #journal-content, after a pause or on a button click ("Get AI Help" or similar), send current content to a specific backend endpoint for AI assistance.
* The backend will use Claude to ask reflective questions.
* Display AI questions and user responses in #journal-ai-chat-area. This chat should be part of the data saved with the journal entry.
* Range Slider Value Display: Update span elements (e.g., #journal-mood-value) when range sliders change.
* Image Preview: For #journal-image-upload.
* MCP Tool Toggles:
* Function to fetch available MCP tools for journaling from backend (or define client-side if static).
* Dynamically create toggle switches (checkboxes) in #journal-mcp-toggles.
* Store toggle states (e.g., in localStorage or send with entry data).
* "Daily Metrics" Form (#daily-metrics-form):
* Event listener for submit.
* Collect form data.
* Call backend API (/api/journal/metrics - POST) with the data.
* Handle response: Display success/error. Display calculated well-being score in #wellbeing-score-display.
* API Service (apiService.js or similar - new/extended):
* Functions to make authenticated fetch requests to backend journal endpoints.
* saveJournalEntry(entryData)
* saveDailyMetrics(metricsData)
* getJournalAiAssistance(text) (for interactive journaling chat)
3.3. Styling:
* Style journal tabs and active tab state.
* Style forms, inputs, sliders, and buttons consistent with the Tron theme.
* Ensure a clear and usable layout for both forms.
* Style the AI chat area within the journal entry form.
* Style toggle switches.
3.4. API Interaction:
* POST /api/journal/entry:
* Payload: { title: "...", content: "...", image_base64: "...", mood: 5, energy: 7, ..., mcp_tools_enabled: { tagging: true } }
* Response: Success/error message, possibly the created entry data.
* POST /api/journal/metrics:
* Payload: { date: "YYYY-MM-DD", sleep: 7.5, water: 8, ... }
* Response: Success/error, calculated well-being score.
* POST /api/journal/assist (or similar for interactive AI):
* Payload: { current_text: "...", previous_chat: [...] }
* Response: { ai_question: "...", ai_observation: "..." }
Stage 4: Journaling UI - Recent Entries & Analytics Display
Objective: Implement the "Recent Entries" and "Analytics" tabs in the Journal view.
4.1. HTML Structure (index.html within #journal-view):
* "Recent Entries" Tab Content (#journal-tab-recent):
* Container for list/cards of recent entries (<div id="recent-journal-entries-list">).
* Loading indicator.
* Empty state message (e.g., "No journal entries yet.").
* "Analytics" Tab Content (#journal-tab-analytics):
* Placeholders for charts (e.g., mood trend, well-being score over time).
* <div id="mood-chart-container"></div>
* <div id="wellbeing-chart-container"></div>
* Placeholders for summary statistics.
* Modal for Full Journal Entry (<div id="journal-entry-modal" class="modal">):
* Standard modal structure (overlay, content area, close button).
* Content area (<div id="modal-entry-details">) to display full title, date, content, metrics, image, AI observations.
4.2. JavaScript Logic (journal.js continued):
* JournalUI class:
* Fetch Recent Entries:
* Function loadRecentEntries(): Calls backend API (/api/journal/entries - GET).
* On success, dynamically render entries in #recent-journal-entries-list. Each entry should be clickable.
* Display basic info: title, date, snippet.
* Display Full Entry in Modal:
* When a recent entry is clicked, call backend API (/api/journal/entry/{entryId} - GET).
* Populate #modal-entry-details with the full entry data.
* Show the modal. Implement modal close functionality.
* Fetch & Display Analytics (Placeholder):
* Function loadJournalAnalytics(): Calls backend API (/api/journal/analytics - GET).
* (For now, just display raw JSON or a "coming soon" message. Charting libraries like Chart.js can be integrated later).
* apiService.js:
* getRecentJournalEntries()
* getJournalEntryById(entryId)
* getJournalAnalytics()
4.3. Styling:
* Style the list/cards for recent entries.
* Style the modal for displaying full entries.
* Basic styling for analytics placeholders.
4.4. API Interaction:
* GET /api/journal/entries:
* Response: [{ id: "...", title: "...", date: "...", snippet: "..." }, ...]
* GET /api/journal/entry/{entryId}:
* Response: Full journal entry object including all metrics, content, image URL, AI notes.
* GET /api/journal/analytics:
* Response: { mood_trend_data: [...], wellbeing_history: [...], common_tags: [...] } (structure TBD by backend).
Stage 5: Project Workspace UI - Creation & Listing
Objective: Implement the UI for creating new projects and listing existing ones.
5.1. HTML Structure (index.html within #projects-view):
* Header: "Projects".
* Button: <button id="create-project-btn">Create New Project</button>.
* Container for projects list: <div id="projects-list-container"></div>.
* Loading indicator.
* Empty state message.
* Modal for Create/Edit Project (<div id="project-modal" class="modal">):
* Form (<form id="project-form">):
* Project Name input: <input type="text" id="project-name-input" name="projectName" required>.
* Project Description textarea: <textarea id="project-description-input" name="projectDescription"></textarea>.
* System Prompt/Rules textarea: <textarea id="project-system-prompt-input" name="systemPrompt"></textarea> (for project-specific AI instructions).
* Save button, Cancel button.
* Hidden input for project ID (for editing).
5.2. JavaScript Logic (projects.js - new file):
* Module/Class ProjectUI:
* Event Listener for #create-project-btn: Open #project-modal in "create" mode (clear form, set modal title).
* #project-form Submit Logic:
* Prevent default submission.
* Collect form data.
* If editing, call updateProject() API; else, call createProject() API.
* On success: Close modal, refresh projects list. Display success message.
* On error: Display error message.
* Function loadProjects():
* Call backend API (/api/projects - GET).
* Render projects in #projects-list-container. Each project should display name, description snippet, and have "Open", "Edit", "Delete" buttons.
* Edit Project Logic:
* When "Edit" button clicked: Populate #project-form with project data, set modal to "edit" mode, store project ID.
* Delete Project Logic:
* When "Delete" button clicked: Confirm with user. Call backend API (/api/projects/{projectId} - DELETE). Refresh list on success.
* Open Project Logic:
* When "Open" button clicked: Navigate to a project-specific chat view (details in Stage 6). This might involve setting a global state for the current project and switching to a chat view pre-configured for that project.
* apiService.js:
* getProjects()
* createProject(projectData)
* updateProject(projectId, projectData)
* deleteProject(projectId)
5.3. Styling:
* Style the projects list (cards or list items).
* Style the project creation/edit modal and form.
5.4. API Interaction:
* GET /api/projects: Response: [{ id: "...", name: "...", description: "..." }, ...].
* POST /api/projects: Payload: { name: "...", description: "...", systemPrompt: "..." }. Response: Created project object.
* PUT /api/projects/{projectId}: Payload: { name: "...", description: "...", systemPrompt: "..." }. Response: Updated project object.
* DELETE /api/projects/{projectId}: Response: Success/error message.
Stage 6: Project Workspace UI - File Management & Project Chat Context
Objective: Implement file uploads for projects and the project-specific chat interface.
6.1. HTML Structure (index.html):
* Within Project View (when a project is "opened" or selected):
* Display project name and description.
* File Management Section (<div id="project-files-section">):
* File upload input: <input type="file" id="project-file-upload" multiple>.
* List of uploaded files for the project (<ul id="project-files-list">). Each item shows filename, type, size, and a delete button.
* Project Chat Section (<div id="project-chat-interface">):
* This will be a standard chat interface (messages, input, send button) similar to the main chat view but specifically for the current project.
* It should clearly indicate which project is active.
* The system prompt for this chat will be loaded from the project's settings.
6.2. JavaScript Logic (projects.js continued, and potentially chat.js adaptations):
* ProjectUI class:
* File Upload Logic (#project-file-upload change event):
* Get selected files.
* For each file, call backend API (/api/projects/{projectId}/files - POST) to upload. This might involve FormData.
* On success, refresh the project files list.
* List Project Files:
* Function loadProjectFiles(projectId): Call backend API (/api/projects/{projectId}/files - GET).
* Render files in #project-files-list.
* Delete Project File:
* Event listener for delete buttons on files. Call backend API (/api/projects/{projectId}/files/{fileId} - DELETE). Refresh list.
* Open Project Chat:
* When a project is opened, fetch its details (including system prompt).
* Initialize/configure the #project-chat-interface with this project's context.
* WebSocket messages for this chat should include projectId.
* Chat Logic (chat.js or adapted):
* The main sendMessage function might need to be adapted or a new one created for project chats to include projectId in the WebSocket payload.
* The WebSocket backend will need to handle this projectId to use the correct context (system prompt, project files) when interacting with Claude.
6.3. Styling:
* Style the file upload area and the list of project files.
* Ensure the project chat interface is clearly distinguished (e.g., header indicating project name).
6.4. API Interaction:
* GET /api/projects/{projectId}/files: Response: [{ id: "...", name: "...", type: "...", size: "..." }, ...].
* POST /api/projects/{projectId}/files: Payload: File data (e.g., FormData). Response: Uploaded file details.
* DELETE /api/projects/{projectId}/files/{fileId}: Response: Success/error.
* WebSocket messages for project chat:
* Send: { type: 'text', role: 'user', content: '...', projectId: '...' }.
* Backend uses projectId to fetch system prompt and relevant file context for Claude.
Stage 7: Settings UI
Objective: Implement the settings interface.
7.1. HTML Structure (index.html within #settings-view):
* Appearance Section:
* Theme selection dropdown (Dark, Light - Light disabled for now).
* Font size selection.
* Chat Settings Section:
* Model selection (dropdown, currently hardcoded to Claude 3.7 Sonnet but built for future flexibility).
* "Clear Chat History" button (<button id="clear-chat-history-btn">).
* MCP Tool Toggles (Global or link to Journal section):
* If there are global MCP tools (like n8n) that apply to all chats, include toggles here.
* Otherwise, this section might just explain that journal-specific tools are in the Journal section.
* About Section: Display app version and brief description.
7.2. JavaScript Logic (settings.js - new file, and app.js):
* Module/Class SettingsUI:
* Load/Save Settings:
* Load settings (theme, font size, model preference) from localStorage on init.
* Apply loaded settings to the UI.
* Save settings to localStorage when changed.
* Event Listener for #clear-chat-history-btn:
* Confirm with user.
* Clear chat history from localStorage.
* Clear messages from the DOM in the main chat view.
* Display a success message.
* MCP Tool Toggles (if any global ones):
* Similar logic to journal MCP toggles for managing their state.
7.3. Styling:
* Style settings sections, labels, dropdowns, and buttons.
7.4. API Interaction:
* No direct backend API calls for most settings (client-side localStorage).
* Clearing chat history is client-side.
Stage 8: Global Components & Final Polish
Objective: Implement reusable global UI components and perform a final review.
8.1. Components to Implement/Refine:
* Modals: Ensure a consistent modal component is used for Journal Entry View, Project Create/Edit.
* Proper open/close mechanisms (button, escape key, click outside).
* Notifications/Toast Messages:
* Implement a system for displaying temporary messages (e.g., "Entry Saved", "Error connecting to backend").
* Style for success, error, info.
* Loading Indicators:
* Use consistent loading indicators (e.g., spinners) when fetching data or performing actions.
* Disable buttons during operations to prevent multiple submissions.
* Image Previews: Standardise image preview component for chat and journal.
8.2. JavaScript Logic (potentially in a ui.js or integrated into app.js):
* Functions to show/hide modals programmatically.
* Function to display toast notifications.
* Functions to show/hide global loading indicators or manage button states.
8.3. Styling:
* Ensure all global components are styled consistently with the Tron theme.
* Perform a full UI review for consistency, responsiveness, and visual appeal.
8.4. Final Review:
* Test all functionalities across different browsers (if possible) and screen sizes.
* Check for console errors.
* Review code for clarity and comments.
This staged approach should provide a clear path for the LLM coder to implement the frontend. Each stage builds upon the previous one, allowing for iterative development and testing.
