NeonChat Backend Journal Feature: Technical Specification for LLM Implementation
1. Introduction
This document outlines the backend technical specifications for the "Journal" feature in the NeonChat application. It is intended to guide an LLM coder in implementing the necessary FastAPI services, API endpoints, data models, and interactions with Obsidian, Firebase Storage, and the Anthropic Claude API.
Core Technologies:
Framework: Python FastAPI
AI Model: Anthropic Claude (via API)
Primary Data Store (Journal Entries, Metrics, AI Observations): Obsidian (accessed via Local REST API plugin)
File Storage (Journal Images): Firebase Storage
Authentication: Firebase Authentication (ID token verification)
Guiding Principles for Implementation:
Modular Design: Services and routes should be organized logically.
Security: All journal-related endpoints must be authenticated and user-scoped.
Obsidian-centric: Journal entries, including their structured metrics and AI-generated content, will be stored as Markdown files in Obsidian.
AI-Assisted Interaction: Leverage Claude for interactive journaling, automated tagging, and generating insightful observations.
Clear API Contracts: Well-defined Pydantic models for request and response bodies.
Asynchronous Operations: Utilize async and await for I/O-bound operations.
2. Data Models (Pydantic)
Define/extend these models in a new or existing file, e.g., backend/app/models/journal.py.
# backend/app/models/journal.py
from pydantic import BaseModel, Field, HttpUrl
from typing import List, Optional, Dict, Any, Union
from datetime import datetime, date
import uuid

# --- Metrics Models ---
class JournalMetricItem(BaseModel):
    name: str # e.g., "Mood", "Energy Level", "Sleep Hours"
    value: Union[int, float, str] # Can be a scale (1-10), hours, or a category
    unit: Optional[str] = None # e.g., "hours", "glasses", "minutes"

class DailyMetricsBase(BaseModel):
    entry_date: date = Field(default_factory=date.today)
    # User-defined metrics (flexible)
    # Example core metrics (can be expanded by frontend)
    sleep_hours: Optional[float] = Field(None, ge=0, le=24)
    water_intake_glasses: Optional[int] = Field(None, ge=0)
    exercise_minutes: Optional[int] = Field(None, ge=0)
    mood_score: Optional[int] = Field(None, ge=1, le=10) # Overall daily mood
    stress_level: Optional[int] = Field(None, ge=1, le=10)
    energy_level: Optional[int] = Field(None, ge=1, le=10)
    # Add more specific metrics as defined in the frontend UI spec
    # e.g., work_satisfaction, social_interaction_quality, etc.
    custom_metrics: Optional[List[JournalMetricItem]] = [] # For additional, dynamic metrics

class DailyMetricsCreate(DailyMetricsBase):
    pass

class DailyMetricsResponse(DailyMetricsBase):
    id: str # Unique ID for the metrics entry (e.g., YYYY-MM-DD or UUID)
    user_id: str
    created_at: datetime
    updated_at: datetime
    calculated_well_being_score: Optional[float] = None

# --- Journal Entry Models ---
class JournalEntryBase(BaseModel):
    title: Optional[str] = None
    # User's main textual content for the journal entry
    user_content: str
    # Structured metrics recorded at the time of entry
    entry_metrics: Optional[List[JournalMetricItem]] = []
    # URL of an image associated with the entry, stored in Firebase Storage
    image_url: Optional[HttpUrl] = None
    # Base64 encoded image data for upload, not stored directly in Obsidian
    image_base64: Optional[str] = Field(None, exclude=True) # Exclude from response model if not needed
    entry_date: date = Field(default_factory=date.today)

class JournalEntryCreate(JournalEntryBase):
    # Interactive chat transcript with AI during journaling
    # Each dict: { "speaker": "user" | "ai", "text": "...", "timestamp": "..." }
    interactive_chat_transcript: Optional[List[Dict[str, Any]]] = []
    # Which MCP tools were enabled by the user for this entry
    mcp_tools_enabled: Optional[Dict[str, bool]] = {}

class JournalEntryResponse(JournalEntryBase):
    id: str # Unique ID for the journal entry (e.g., filename or UUID)
    user_id: str
    created_at: datetime
    updated_at: datetime
    # Content generated by AI
    ai_tags: Optional[List[str]] = []
    ai_summary: Optional[str] = None
    ai_observations: Optional[str] = None # "Therapist notes"
    # Full interactive chat transcript
    interactive_chat_transcript: Optional[List[Dict[str, Any]]] = []
    # Path to the note in Obsidian
    obsidian_note_path: str

# --- Journal Analytics Models ---
class MoodTrendPoint(BaseModel):
    date: date
    mood_score: Optional[float] # Average mood for the day or entry mood

class WellBeingTrendPoint(BaseModel):
    date: date
    well_being_score: Optional[float]

class TagFrequency(BaseModel):
    tag: str
    count: int

class JournalAnalyticsResponse(BaseModel):
    mood_trend: List[MoodTrendPoint] = []
    well_being_trend: List[WellBeingTrendPoint] = []
    common_tags: List[TagFrequency] = []
    total_entries: int = 0
    average_words_per_entry: Optional[float] = None
    # Potentially more analytics like writing streaks, sentiment distribution etc.

# For WebSocket messages related to AI-assisted journaling
class JournalAssistMessage(BaseModel):
    current_text: str
    previous_chat_transcript: Optional[List[Dict[str, Any]]] = []
    entry_metrics: Optional[List[JournalMetricItem]] = [] # Context for AI

class JournalAssistResponse(BaseModel):
    ai_question: Optional[str] = None # Question from AI to prompt user
    ai_suggestion: Optional[str] = None # Suggestion for content
    ai_interim_observation: Optional[str] = None # Quick observation


3. API Endpoints (FastAPI)
Create a new router, e.g., backend/app/api/routes/journal.py. All endpoints require authentication.
POST /api/journal/entries
Request Body: JournalEntryCreate
Response Body: JournalEntryResponse
Action:
Validate input.
If image_base64 is present, upload it to Firebase Storage and get the image_url.
Process user_content and interactive_chat_transcript with Claude (via AnthropicService) to:
Generate ai_tags.
Generate ai_summary.
Generate ai_observations.
Suggest [[wikilinks]] to embed in content.
Calculate well-being score if relevant metrics are present (or call a dedicated metrics calculation).
Create a new Markdown note in Obsidian: Vault/Journal/{YYYY}/{MM}/{YYYY-MM-DD_HHMMSS_slugified_title_or_uuid}.md.
Frontmatter: Store id (UUID), title, entry_date, user_id, created_at, updated_at, image_url, entry_metrics, ai_tags, ai_summary, calculated_well_being_score (if applicable).
Body: Store user_content, formatted interactive_chat_transcript, and ai_observations. Embed wikilinks.
Return the JournalEntryResponse.
GET /api/journal/entries
Query Params: limit: int = 10, offset: int = 0, start_date: Optional[date] = None, end_date: Optional[date] = None
Response Body: List[JournalEntryResponse]
Action:
List all relevant .md files from the user's Vault/Journal/ directory structure in Obsidian, applying date filters if provided.
For each file, parse its frontmatter and a snippet of the body to construct JournalEntryResponse objects.
Implement pagination using limit and offset.
Return the list of journal entries.
GET /api/journal/entries/{entry_id}
Response Body: JournalEntryResponse
Action:
The entry_id could be the filename (without extension but with timestamp/UUID part) or a UUID stored in frontmatter. Determine a consistent way to reference entries. Assume entry_id helps locate the file path.
Read the specified journal note from Obsidian.
Parse frontmatter and body to construct the full JournalEntryResponse.
If not found, return 404.
PUT /api/journal/entries/{entry_id}
Request Body: JournalEntryCreate (or a specific JournalEntryUpdate model)
Response Body: JournalEntryResponse
Action:
Read the existing journal note.
If image_base64 is provided and different, update/upload to Firebase Storage.
Re-process content with Claude if user_content or interactive_chat_transcript changed significantly.
Update frontmatter and body content. Update updated_at.
Save the updated note in Obsidian.
Return the updated JournalEntryResponse.
DELETE /api/journal/entries/{entry_id}
Response Status: 204 No Content or success message.
Action:
Read the journal note to get image_url if present.
Delete the Markdown note from Obsidian.
If an image was associated, delete it from Firebase Storage.
POST /api/journal/metrics
Request Body: DailyMetricsCreate
Response Body: DailyMetricsResponse
Action:
Validate input.
Calculate calculated_well_being_score based on the provided metrics (this logic could be in JournalService or use Claude if complex interpretation is needed).
Save/update daily metrics as a dedicated Markdown note in Obsidian (e.g., Vault/Journal/Metrics/{YYYY-MM-DD}.md) or as part of a daily note. Frontmatter should store all metrics and the calculated score.
Return the saved DailyMetricsResponse.
GET /api/journal/metrics
Query Params: start_date: date, end_date: date
Response Body: List[DailyMetricsResponse]
Action:
Fetch daily metrics notes from Obsidian for the given date range.
Parse and return as a list of DailyMetricsResponse.
POST /api/journal/assist (For interactive AI journaling chat within the entry form)
Request Body: JournalAssistMessage
Response Body: JournalAssistResponse (streaming if possible, or single response)
Action:
Take current_text from the journal content field and previous_chat_transcript.
Send to AnthropicService with a specific system prompt designed for interactive journaling (e.g., "You are a reflective journaling assistant. Ask open-ended questions to help the user explore their thoughts and feelings based on what they've written. Keep responses concise.").
Claude responds with a question or a brief suggestion.
Return this to the frontend to display in the journal entry's AI chat pane.
GET /api/journal/analytics
Query Params: period: str = "last_30_days" (e.g., "last_7_days", "last_3_months")
Response Body: JournalAnalyticsResponse
Action:
Fetch relevant journal entries and metrics data from Obsidian for the specified period.
Perform calculations for mood trends, well-being trends, common tags, etc.
Return the JournalAnalyticsResponse.
4. Core Services & Logic
4.1. JournalService (e.g., backend/app/services/journal_service.py - new file):
* Contains business logic for journal entries and daily metrics.
* Interacts with ObsidianService, FirebaseService, and AnthropicService.
* Key methods:
* async def create_journal_entry(user_id: str, entry_data: JournalEntryCreate) -> JournalEntryResponse: (Handles image upload, AI processing, Obsidian note creation).
* async def get_journal_entry(user_id: str, entry_id: str) -> Optional[JournalEntryResponse]:
* async def list_journal_entries(user_id: str, limit: int, offset: int, start_date: Optional[date], end_date: Optional[date]) -> List[JournalEntryResponse]:
* async def update_journal_entry(user_id: str, entry_id: str, entry_data: JournalEntryCreate) -> Optional[JournalEntryResponse]:
* async def delete_journal_entry(user_id: str, entry_id: str) -> bool:
* async def save_daily_metrics(user_id: str, metrics_data: DailyMetricsCreate) -> DailyMetricsResponse:
* async def get_daily_metrics_range(user_id: str, start_date: date, end_date: date) -> List[DailyMetricsResponse]:
* async def get_journal_ai_assistance(user_id: str, assist_message: JournalAssistMessage) -> JournalAssistResponse:
* async def calculate_journal_analytics(user_id: str, period: str) -> JournalAnalyticsResponse:
* def _calculate_well_being_score(metrics: DailyMetricsBase) -> float: (Internal logic for well-being score).
4.2. ObsidianService (extensions for journaling):
* Ensure methods can handle the specific directory structure for journals and metrics.
* Methods to parse frontmatter and body content effectively.
4.3. FirebaseService (extensions for journal images):
* async def upload_journal_image(user_id: str, entry_date_str: str, image_bytes: bytes, content_type: str) -> str: (Returns public URL. Path could be users/{user_id}/journal_images/{entry_date_str}/{uuid}.jpg).
* async def delete_file_by_url(file_url: str) -> bool:
4.4. AnthropicService (api_service.py modifications/extensions):
* async def get_journaling_ai_enhancements(user_content: str, interactive_chat_transcript: Optional[List[Dict]], mcp_tools_enabled: Dict) -> Dict[str, Any]:
* Takes user content and chat.
* Uses Claude with specific prompts to generate tags, summary, observations, and suggest wikilinks.
* If MCP tools (like n8n for advanced tagging) are enabled, configures the Claude call accordingly.
* Returns a dict like { "ai_tags": [...], "ai_summary": "...", "ai_observations": "...", "suggested_wikilinks": [...] }.
* async def get_interactive_journal_prompt(assist_message: JournalAssistMessage) -> JournalAssistResponse:
* Takes current text and chat history.
* Prompts Claude to ask a reflective question or make a suggestion.
5. Data Storage in Obsidian
Journal Entries:
Path: Vault/Journal/{YYYY}/{MM}/{YYYY-MM-DD_HHMMSS_slug_or_uuid}.md
Example: Vault/Journal/2025/05/2025-05-24_103000_feeling-reflective.md
Frontmatter Example:
---
id: "entry-uuid-123"
title: "Feeling Reflective Today"
entry_date: "2025-05-24" # Actual date of the entry content
created_at: "2025-05-24T10:30:00Z"
updated_at: "2025-05-24T10:35:00Z"
user_id: "firebase-user-uid"
image_url: "https://firebasestorage.googleapis.com/..." # Optional
entry_metrics:
  - name: "Mood"
    value: 7
    unit: "1-10"
  - name: "Energy Level"
    value: 6
    unit: "1-10"
ai_tags: ["reflection", "work", "family", "[[Alfie]]"]
ai_summary: "User reflected on their day, focusing on work challenges and positive family interactions."
# calculated_well_being_score: 7.5 # If applicable directly to this entry
---


Body Content Example:
# Feeling Reflective Today

## My Thoughts
{{user_content_goes_here_with_potential_wikilinks}}
For example, I was thinking about the [[Project Alpha]] deadline.

## AI Interaction
**AI:** How did the discussion about [[Project Alpha]] make you feel?
**User:** A bit stressed, but also motivated.
{{more_interactive_chat_transcript}}

## AI Observations
{{ai_observations_go_here}}
The user seems to be balancing stress with motivation regarding [[Project Alpha]]. They mentioned [[Alfie]] in a positive context.


Daily Metrics Notes:
Path: Vault/Journal/Metrics/{YYYY-MM-DD}.md
Frontmatter Example:
---
id: "metrics-2025-05-24-uuid"
entry_date: "2025-05-24"
user_id: "firebase-user-uid"
created_at: "2025-05-24T08:00:00Z"
updated_at: "2025-05-24T08:00:00Z"
sleep_hours: 7.5
water_intake_glasses: 8
exercise_minutes: 30
mood_score: 8 # Overall daily mood
stress_level: 3
energy_level: 7
# ... other core metrics
custom_metrics:
  - name: "Gratitude Moments"
    value: 3
  - name: "Weather"
    value: "Sunny"
calculated_well_being_score: 8.2
---

# Daily Metrics for 2025-05-24

Well-being Score: 8.2/10

* Sleep: 7.5 hours
* Mood: 8/10
* ... (other metrics can be listed here for readability if desired)


6. Staged Implementation Plan (Backend - Journal Feature)
Stage BJ1: Journal & Metrics Models, Core Service Stubs
* Implement Pydantic models (JournalEntryCreate, JournalEntryResponse, DailyMetricsCreate, DailyMetricsResponse, JournalMetricItem, JournalAssistMessage, JournalAssistResponse, analytics models).
* Create JournalService with method stubs for all key functionalities.
* Extend ObsidianService and FirebaseService with stubs for new journal-specific methods.
* Focus: Defining the data structures and service interfaces.
Stage BJ2: Daily Metrics API & Service Logic
* Implement JournalService.save_daily_metrics and JournalService.get_daily_metrics_range.
* This includes the logic for _calculate_well_being_score.
* Interaction with ObsidianService to store/retrieve metrics notes.
* Implement FastAPI endpoints: POST /api/journal/metrics, GET /api/journal/metrics.
* Integrate Firebase authentication.
* Focus: Storing and retrieving structured daily wellness data in Obsidian.
Stage BJ3: Journal Entry Creation (Basic - No AI Chat/Full AI Processing Yet)
* Implement FirebaseService.upload_journal_image.
* Implement the core of JournalService.create_journal_entry:
* Handle image upload via FirebaseService.
* Save the basic user_content and entry_metrics to an Obsidian note using ObsidianService. Store image_url in frontmatter. For now, ai_tags, ai_summary, ai_observations can be empty or placeholder.
* Implement POST /api/journal/entries endpoint (basic version).
* Focus: Saving a journal entry with its core user data and image to Obsidian.
Stage BJ4: Interactive AI Journaling Assistance
* Implement AnthropicService.get_interactive_journal_prompt.
* Implement JournalService.get_journal_ai_assistance.
* Implement POST /api/journal/assist endpoint. This endpoint will be called by the frontend as the user types in the journal entry form to get AI prompts/questions.
* The interactive_chat_transcript will be built up on the frontend and sent as part of the final JournalEntryCreate payload.
* Focus: Enabling the AI to ask reflective questions during journal entry creation.
Stage BJ5: Full AI Processing for Journal Entries & Saving
* Implement AnthropicService.get_journaling_ai_enhancements to get tags, summary, observations, and wikilink suggestions from Claude.
* Enhance JournalService.create_journal_entry (and update_journal_entry) to:
* Call get_journaling_ai_enhancements after user content and interactive chat are finalized.
* Incorporate the AI-generated fields (ai_tags, ai_summary, ai_observations) into the Obsidian note's frontmatter and body.
* Embed suggested [[wikilinks]] into the user_content and interactive_chat_transcript before saving.
* Focus: Enriching journal entries with AI insights and structuring them for Obsidian's knowledge graph.
Stage BJ6: Journal Entry Retrieval, Update, Delete API Endpoints
* Implement JournalService methods: get_journal_entry, list_journal_entries, update_journal_entry, delete_journal_entry.
* list_journal_entries should handle pagination and date filtering by querying Obsidian note structure/frontmatter.
* update_journal_entry will need to handle potential re-processing by AI if content changes significantly.
* delete_journal_entry must also delete associated images from Firebase Storage.
* Implement corresponding FastAPI endpoints: GET /api/journal/entries, GET /api/journal/entries/{entry_id}, PUT /api/journal/entries/{entry_id}, DELETE /api/journal/entries/{entry_id}.
* Focus: Providing full CRUD for journal entries.
Stage BJ7: Journal Analytics API
* Implement JournalService.calculate_journal_analytics. This will involve:
* Fetching a range of journal entries and metrics notes from Obsidian via ObsidianService.
* Processing this data to calculate trends (mood, well-being) and statistics (common tags, entry counts).
* Implement GET /api/journal/analytics endpoint.
* Focus: Providing data for the analytics tab on the frontend.
Stage BJ8: Testing, Refinement, and Security Review
* Thoroughly test all journal-related API endpoints.
* Verify data integrity between Obsidian, Firebase Storage, and API responses.
* Ensure AI interactions produce desired outputs and are correctly stored.
* Review error handling, authentication, and authorization for all journal operations.
This staged plan should guide the development of the backend journaling features effectively.
